# gibberdiff
Gibbs sampling for finite-state mixtures of regular Brownian motions

## What does it do?

`gibberdiff` analyzes trajectories generated by single-particle
tracking (SPT) experiments using a finite-state mixture model. 
Each component of the mixture is a regular diffusive state, 
characterized by a fractional occupancy and a diffusion coefficient.

The goal of `gibberdiff` is to generate samples from the posterior
distribution over the fractional occupancies and diffusion coefficients,
given some observed trajectories. `gibberdiff` can return either the
raw samples or the estimated posterior mean.

## What doesn't it do?

`gibberdiff` doesn't check the quality of the raw data. Garbage in, garbage out.

`gibberdiff` doesn't decide how many states you should use.

`gibberdiff` doesn't 

`gibberdiff` doesn't deal with transitions between states.

`gibberdiff` doesn't provide any visualizations of the result.

`gibberdiff` doesn't address state identifiability ("label-switching") issues.

`gibberdiff` expects you to understand your own experiment. You need
to know the frame interval, pixel size, and approximate localization
error of your tracking experiment. 

## What goes in and what comes out?

For input, `gibberdiff` expects trajectories in CSV format. Each row of the CSV
should correspond to one detection in a tracking experiment. The CSV
must contain the following columns:

 - `x`: the x coordinate of the detection **in pixels**
 - `y`: the y coordinate of the detection **in pixels**
 - `trajectory`: the index of the trajectory to which the detection belongs
 - `frame`: the index of the frame in which the detection was found

An example is located at `samples/sample_tracks.csv` in this repo.

## Example usage

```
    import pandas as pd
    from gibberdiff import gibberdiff

    # Load some sample trajectories
    tracks = pd.read_csv("samples/sample_tracks.csv")
    
    # Run gibberdiff
    posterior_occs, posterior_diff_coefs = gibberdiff(
        tracks,
        n_states=2, 
        frame_interval=0.01,   # time between frames, seconds
        loc_error=0.035,       # localization error, microns
        dz=0.7,                # focal depth, microns
        pixel_size_um=1.0,     # pixel size, microns
        n_iter=1000,
        burnin=30,
        bounds=(0, 100.0),     # lower and upper limits on diff. coef.
        pseudocount_frac=0.001,
        ret_samples=False
    )
```

## What are the dependencies and how do I install it?

The only non-standard dependency is `tqdm`, which you can get with `pip` or `conda`.

To install, use `python setup.py install` or `python setup.py develop` in an appropriate environment. 

## What do I do with the result?

Up to you.

## Can I get a more detailed description of the model?

See Alec Heckert's thesis. 
